# 🚀 Elasticsearch პროექტის პრეზენტაცია: ფუნდამენტური გზამკვლევი

პრაქტიკული გზამკვლევი: როგორ გადავიტანოთ SQL მონაცემები Elasticsearch-ში, როგორ მუშაობს სისტემა "კაპოტის ქვეშ" და როგორ ავაწყოთ მაღალეფექტური საძიებო სისტემა .NET-ით.

---

## 🏗️ 1. Elasticsearch-ის ფილოსოფია და ფუნდამენტი

Elasticsearch არ არის ჩვეულებრივი ბაზა. მისი მთავარი ძალა სამ სვეტზე დგას:

### 🔍 ა) ინვერსიული ინდექსი (Inverted Index)
ეს არის Elasticsearch-ის "გული". წარმოიდგინეთ წიგნის ბოლო გვერდები, სადაც სიტყვები ანბანურადაა დალაგებული და მითითებულია გვერდები.
*   **SQL:** ძებნა ჰგავს მთელი წიგნის წაკითხვას (ნელია).
*   **Elastic:** სისტემა წინასწარ ქმნის სიას: `ლეპტოპი -> [დოკუმენტი 1, 29, 105]`.
*   ძებნა ხდება პირდაპირ ამ სიაში, რაც უზრუნველყოფს მყისიერ შედეგს მილიონობით ჩანაწერში.

### 🧩 ბ) დანაწილებული არქიტექტურა (Shards & Replicas)
*   **Shard (ნაწილი):** ინდექსი იყოფა დამოუკიდებელ "აგურებად". როცა ეძებთ, ყველა შარდი **პარალელურად** მუშაობს.
*   **Replica (ასლი):** შარდის კოპია. თუ ერთი სერვერი გაითიშება, სისტემა მონაცემებს ასლიდან აიღებს.
*   **განაწილება:** `hash(_id) % shards_count` ფორმულა განსაზღვრავს, რომელ შარდში მოხვდება დოკუმენტი.

### ⚡ გ) მეხსიერების მართვა (RAM & OS Cache)
*   **In-Memory Buffer:** ახალი მონაცემები ჯერ ხვდება RAM-ში.
*   **Filesystem Cache:** `Refresh` (მაგ. 5 წამში ერთხელ) მონაცემებს RAM-იდან გადააქვს **სეგმენტებად**.
*   **სეგმენტები (Segments):** ინვერსიული ინდექსის პატარა ფაილები. რაც უფრო მეტია RAM, მით მეტ სეგმენტს ინახავს OS ქეშში და ძებნა დისკს საერთოდ არ ეხება.

---

## 🧪 2. ანალიზის პროცესი (Analysis Pipeline)

ანალიზი არის ტექსტის "მომზადება" ინვერსიულ ინდექსში ჩაწერამდე.

### ⚙️ როგორ მუშაობს ანალიზატორი?
1.  **Tokenizer:** ტექსტის დაჭრა (მაგ: "MacBook Pro" -> `macbook`, `pro`).
2.  **Filters:**
    *   `Lowercase`: ასოების დაპატარავება.
    *   `Stop Words`: ზედმეტი სიტყვების მოცილება (a, the, and).
    *   `Snowball (Stemming)`: სიტყვის ფუძეზე დაყვანა (running -> run).
    *   `Synonyms`: სინონიმების ჩანაცვლება (notebook = laptop).

### 💡 მნიშვნელოვანი წესი:
ანალიზი ხდება **ორივე მხარეს**:
*   **ჩაწერისას (Indexing Time):** იქმნება ოპტიმიზირებული ტოკენები.
*   **ძებნისას (Search Time):** მომხმარებლის საძიებო სიტყვაც ანალოგიურად მუშავდება, რომ "გასაღები" (query) მოერგოს "საკეტს" (index).

---

## 🛠️ 3. ინდექსის მეპინგი და Settings (პრაქტიკა)

ჩვენს პროექტში ვიყენებთ `products-v2` ინდექსს გაუმჯობესებული სინონიმებით და პაგინაციით.

### 📐 Mapping-ის მაგალითი (NEST / JSON)
```json
PUT /products-v2
{
  "settings": {
    "number_of_shards": 3,
    "refresh_interval": "5s",
    "analysis": {
      "analyzer": {
        "product_name_analyzer": {
          "type": "custom",
          "tokenizer": "standard",
          "filter": ["lowercase", "stop", "snowball", "product_synonyms"]
        }
      },
      "filter": {
        "product_synonyms": {
          "type": "synonym",
          "synonyms": ["laptop, notebook, computer", "phone, smartphone"]
        }
      }
    }
  },
  "mappings": {
    "properties": {
      "name": { 
        "type": "text", 
        "analyzer": "product_name_analyzer",
        "search_analyzer": "product_name_analyzer",
        "fields": { "keyword": { "type": "keyword" } }
      },
      "price": { "type": "float" },
      "category": { "type": "keyword" }
    }
  }
}
```

---

## 📊 4. რანჟირება და რელევანტურობა (_score)

Elasticsearch არ გეუბნებათ მხოლოდ "ვიპოვე თუ არა", ის გეუბნებათ "რამდენად ემთხვევა".

### ⚖️ როგორ ითვლება ქულა?
*   **TF (Term Frequency):** რაც უფრო ხშირად გვხვდება სიტყვა დოკუმენტში, მით მაღალია ქულა.
*   **IDF (Inverse Document Frequency):** რაც უფრო იშვიათია სიტყვა მთელ ბაზაში, მით მეტია მისი "წონა".
*   **Boost:** ხელოვნური პრიორიტეტი. მაგ: `.Field(p => p.Name, boost: 2.0)` ნიშნავს, რომ სახელში დამთხვევა 2-ჯერ უფრო მნიშვნელოვანია.

---

## 🩺 5. დებაგი და მონიტორინგი (Kibana Tools)

როცა ძებნა არ მუშაობს ისე, როგორც გსურთ, გამოიყენეთ ეს ინსტრუმენტები:

### 🔎 ა) Search Profiler (`"profile": true`)
ეს არის Elasticsearch-ის "რენტგენი". გიჩვენებთ დროს თითოეული პირობისთვის:
*   `build_scorer`: რამდენ ხანს ემზადებოდა ალგორითმი.
*   `next_doc`: შემდეგი დოკუმენტის პოვნის დრო.
*   ხედავთ "Bottleneck"-ებს (მაგ. Wildcard ძებნა, რომელიც ანელებს პროცესს).

### 📐 ბ) Explain API (`_explain`)
გპასუხობთ კითხვაზე: "რატომ მოხვდა ეს დოკუმენტი პირველ ადგილზე?".
```json
GET /products-v2/_explain/29 { "query": { "match": { "name": "laptop" } } }
```
პასუხში დაინახავთ ზუსტ მათემატიკურ ფორმულას (Boost * IDF * TF).

### 🧪 გ) Painless Lab
Painless არის Elasticsearch-ის სკრიპტირების ენა (Java-ს მსგავსი).
*   გამოიყენება დინამიური გამოთვლებისთვის (მაგ. ფასდაკლების დათვლა ძებნისას).
*   Lab-ში ტესტავთ უსაფრთხოდ, სანამ რეალურ Query-ში ჩასვამთ.

---

## 🔄 6. სინქრონიზაციის ფლოუ (SQL → Elastic)

1.  **Extract:** SQL Server-დან მონაცემების ამოღება (Hangfire Job).
2.  **Transform:** DTO-ების გარდაქმნა `Product` მოდელად (ტოკენიზაცია ხდება Elastic-ში).
3.  **Load:** `Bulk API`-ს გამოყენებით მონაცემების პაკეტური ჩატვირთვა (მაგ. 1000 ჩანაწერი ერთ რექვესტში).
4.  **Refresh:** 5 წამის შემდეგ მონაცემები ხდება საძიებო.

---

## 💡 7. რჩევები და საუკეთესო პრაქტიკები
*   **Keyword vs Text:** `keyword` გამოიყენეთ ფილტრებისთვის/აგრეგაციისთვის, `text` - ძებნისთვის.
*   **Zero-Downtime:** გამოიყენეთ **Aliases**. პროგრამა ყოველთვის მიმართავს `products_alias`-ს, თქვენ კი ფონურად ქმნით `products_v3`-ს და მერე გადართავთ ალიასს.
*   **Performance:** RAM-ის ნახევარი დაუტოვეთ ოპერაციულ სისტემას Filesystem Cache-ისთვის.
*   **Painless:** გამოიყენეთ მხოლოდ მაშინ, როცა წინასწარ ვერ ითვლით მონაცემებს (მაგ. მანძილის გამოთვლა).

---

## ❓ Q&A
Elasticsearch არის ინსტრუმენტი, რომელიც "უფრო მეტს შრომობს" ჩაწერისას, რათა ძებნისას იყოს მაქსიმალურად მსუბუქი და სწრაფი.
